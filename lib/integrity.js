// Generated by CoffeeScript 1.6.3
(function() {
  var TRM, TYPES, alert, async, badge, debug, echo, help, info, log, njs_fs, njs_path, njs_url, njs_util, rpr, warn, whisper;

  njs_util = require('util');

  njs_path = require('path');

  njs_fs = require('fs');

  njs_url = require('url');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'USERDB/core';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  /* https://github.com/caolan/async*/


  async = require('async');

  this.test_integrity = function(me, id_hint, handler) {
    /*
    * primary record not available
    * primary record type mismatch
    * secondary records not available
    * secondary records with wrong value
    */

    var Z, assumed_type, error, errors, misfit, pkn, pkv, prk, problems, _ref,
      _this = this;
    misfit = ['misfit'];
    try {
      _ref = this._id_triplet_from_hint(me, id_hint), assumed_type = _ref[0], pkn = _ref[1], pkv = _ref[2];
      prk = this._primary_record_key_from_id_triplet(me, assumed_type, pkn, pkv);
    } catch (_error) {
      error = _error;
      alert('©3e2d', error);
      throw error;
    }
    problems = {
      'secondary-fields-missing': []
    };
    errors = {
      'primary-record-missing': false,
      'primary-record-type-mismatch': false,
      'actual-schema-missing': false,
      'secondary-records-missing': [],
      'secondary-records-wrong': []
    };
    Z = {
      '~isa': 'USERDB/entry-integrity-report',
      'id-hint': id_hint,
      'assumed-type': assumed_type,
      'actual-type': null,
      'prk': prk,
      'error-count': 0,
      'problem-count': 0,
      'messages': [],
      'errors': errors,
      'problems': problems,
      'primary-entry': null,
      'secondary-entries': []
    };
    this.entry_from_primary_record_key(me, prk, misfit, function(error, entry) {
      var actual_type, idx, pkn_and_skns, skns, skns_and_srks, srks, test, _ref1, _ref2;
      if (error != null) {
        if (/^unable to find schema for type /.test(error['message'])) {
          Z['error-count'] += 2;
          Z['messages'].push(error['message']);
          Z['messages'].push("unable to build PRK from unknown type");
          errors['actual-schema-missing'] = true;
          errors['primary-record-missing'] = true;
          return handler(null, Z);
        }
        return handler(error);
      }
      Z['primary-entry'] = entry;
      Z['actual-type'] = actual_type = TYPES.type_of(entry);
      if (entry === misfit) {
        Z['error-count'] += 1;
        Z['messages'].push("no entry with prk " + (rpr(prk)));
        errors['primary-record-missing'] = true;
      } else if (actual_type !== assumed_type) {
        Z['error-count'] += 1;
        Z['messages'].push("assumed type was " + (rpr(assumed_type)) + ", actual type is " + (rpr(actual_type)));
        errors['primary-record-type-mismatch'] = true;
      }
      /* should we check for extraneous matches ??? — would have to search all keys matching `* /~prk`*/

      /* should check for secondary entries matching actual type as well*/

      _ref1 = pkn_and_skns = _this._key_names_from_type(me, assumed_type), pkn = _ref1[0], skns = _ref1[1];
      _ref2 = _this._get_primary_and_secondary_record_keys(me, entry, pkn_and_skns), prk = _ref2[0], srks = _ref2[1];
      skns_and_srks = (function() {
        var _i, _ref3, _results;
        _results = [];
        for (idx = _i = 0, _ref3 = skns.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; idx = 0 <= _ref3 ? ++_i : --_i) {
          _results.push([skns[idx], srks[idx]]);
        }
        return _results;
      })();
      test = function(skn_and_srk, done) {
        var skn, srk;
        skn = skn_and_srk[0], srk = skn_and_srk[1];
        if (srk == null) {
          Z['problem-count'] += 1;
          Z['messages'].push("secondary field " + (rpr(skn)) + " is missing");
          problems['secondary-fields-missing'].push(skn);
          return done(null);
        } else {
          /* TAINT should also check for records that correspond to missing secondary fields*/

          return _this.entry_from_primary_record_key(me, srk, misfit, function(error, secondary) {
            if (error != null) {
              return done(error);
            }
            if (secondary === misfit) {
              Z['error-count'] += 1;
              Z['messages'].push("secondary record with SRK " + (rpr(srk)) + " is missing");
              errors['secondary-records-missing'].push(skn);
              return done(null);
            } else if (secondary !== prk) {
              Z['error-count'] += 1;
              Z['messages'].push("secondary record with SRK " + (rpr(srk)) + " should be PRK " + (rpr(prk)) + ", is " + (rpr(secondary)));
              errors['secondary-records-wrong'].push(skn);
            }
            Z['secondary-entries'].push({
              skn: skn,
              srk: srk,
              value: secondary
            });
            return done(null);
          });
        }
      };
      return async.each(skns_and_srks, test, function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, Z);
      });
    });
    return null;
  };

}).call(this);
